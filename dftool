#!/usr/bin/env python

import csv
import os
import sys

import brownie

from util.constants import BROWNIE_PROJECT
from util.base18 import toBase18, fromBase18
from util.graphutil import oceanSubgraphUrl
from util.oceanutil import recordDeployedContracts
from util.rewardsutil import BlockRange, calcRewards

NETWORKS = ['development', 'eth_mainnet'] #development = ganache

# ========================================================================
HELP_MAIN = """Data Farming Tool - main help

Usage: dftool calc|dispense|..

  dftool calc - calculate rewards
  dftool dispense - airdrop funds based on calculations

  dftool mine - force chain to pass time (ganache only)

  dftool accountinfo - info about an account
  dftool chaininfo - info about a network
  dftool help - this message

Transactions are signed with envvar 'DFTOOL_KEY`.
"""
def show_help():
    print(HELP_MAIN)
    sys.exit(0)
    
# ========================================================================
def do_calc():
    HELP_CALC = f"""Data Farming Tool - calculate rewards

Usage: dftool calc NETWORK START END INTERVAL OCEAN OUTPUT_DIR

  NETWORK -- one of {NETWORKS}
  START -- block # to start calcs on
  END -- block # to end calcs
  INTERVAL -- sample every nth block
  OCEAN -- amount of OCEAN to distribute (in decimal, not wei)
  OUTPUT_DIR -- output directory for csv file.

Uses these envvars:
  ADDRESS_FILE -- e.g. for barge ~/.ocean/ocean-contracts/artifacts/address.json
  SUBGRAPH_URI -- e.g. for barge http://127.0.0.1:9000
"""

    if len(sys.argv) not in [2+6]:
        print(HELP_CALC)
        sys.exit(0)

    # extract inputs
    assert sys.argv[1] == "calc"
    NETWORK = sys.argv[2]
    START, END, INTERVAL = int(sys.argv[3]), int(sys.argv[4]), int(sys.argv[5])
    OCEAN = float(sys.argv[6])
    OUTPUT_DIR = sys.argv[7]
    print(f"Arguments:\n NETWORK={NETWORK}" \
          f"\n START={START}\n END={END}\n INTERVAL={INTERVAL}" \
          f"\n OCEAN={OCEAN}" \
          f"\n OUTPUT_DIR={OUTPUT_DIR}")
        
    # extract envvars
    ADDRESS_FILE = os.environ.get('ADDRESS_FILE')
    SUBGRAPH_URI = os.environ.get('SUBGRAPH_URI')
    print(f"Envvars:\n ADDRESS_FILE={ADDRESS_FILE}\n " \
          f"SUBGRAPH_URI={SUBGRAPH_URI}")

    # corner cases
    if os.path.exists(OUTPUT_DIR):
        print(f"\nOutput path '{OUTPUT_DIR}' already exists.  Exiting.\n")
        sys.exit(0)
    if ADDRESS_FILE is None:
        print("\nNeed to set envvar ADDRESS_FILE. Exiting.\n"); sys.exit(0)
    if SUBGRAPH_URI is None:
        print("\nNeed to set envvar SUBGRAPH_URI. Exiting.\n"); sys.exit(0)

    # make directory
    os.mkdir(OUTPUT_DIR)
    
    #brownie setup
    brownie.network.connect(NETWORK)
    accounts = brownie.network.accounts
    chain = brownie.network.chain
    assert END <= len(chain)

    #main work
    recordDeployedContracts(ADDRESS_FILE, NETWORK)
    
    block_range = BlockRange(START, END, INTERVAL)

    subgraph_url = oceanSubgraphUrl(SUBGRAPH_URI)
    rewards = calcRewards(OCEAN, block_range, subgraph_url)
    
    #store to csv
    csv_file = os.path.join(OUTPUT_DIR, "rewards.csv")
    with open(csv_file, 'w') as f:
        writer = csv.writer(f)
        writer.writerow(["address", "OCEAN_reward"])
        for address, OCEAN_reward in rewards.items():
            writer.writerow([address, OCEAN_reward])

    #
    print(f"Created output directory: {OUTPUT_DIR}")
    print(f"dftool calc: Done.")

# ========================================================================
def do_dispense():
    HELP_DISPENSE = f"""Data Farming Tool - airdrop funds based on calculations

Usage: dftool dispense NETWORK INPUT_DIR

  NETWORK -- one of {NETWORKS}
  INPUT_DIR -- string -- input directory for csv file.
"""
    if len(sys.argv) not in [4]:
        print(HELP_DISPENSE)
        sys.exit(0)

    # extract inputs
    assert sys.argv[1] == "dispense"
    NETWORK = sys.argv[2]
    INPUT_DIR = sys.argv[3]

    print(f"Arguments: NETWORK={NETWORK}, INPUT_DIR={INPUT_DIR}")

    #brownie setup
    brownie.network.connect(NETWORK) 
    accounts = brownie.network.accounts
    from_account = _getPrivateAccount()

    #
    print("FIXME: do rest of 'dispense' work now!!")
    
    print("dftool dispense: Done.")


   
# ========================================================================
def do_mine():
    HELP_MINE = f"""Vesting wallet - force chain to pass time (ganache only)

Usage: dftool mine BLOCKS [TIMEDELTA]

  BLOCKS -- e.g. 3
  TIMEDELTA -- e.g. 100"""
    if len(sys.argv) not in [3,4]:
        print(HELP_MINE)
        sys.exit(0)

    # extract inputs
    assert sys.argv[1] == "mine"
    BLOCKS = int(sys.argv[2])
    if len(sys.argv) == 4:
        TIMEDELTA = int(sys.argv[3])
    else:
        TIMEDELTA = None

    print(f"Arguments: BLOCKS={BLOCKS}, TIMEDELTA={TIMEDELTA}")

    #brownie setup
    NETWORK = 'development' #hardcoded bc it's the only one we can force
    brownie.network.connect(NETWORK) 
    accounts = brownie.network.accounts
    chain = brownie.network.chain
    from_account = _getPrivateAccount()

    #make time pass
    if TIMEDELTA is None:
        chain.mine(blocks=BLOCKS, timedelta=TIMEDELTA)
    else:
        chain.mine(blocks=BLOCKS)
        
    print("dftool mine: Done.")


# ========================================================================
def show_accountinfo():
    HELP_ACCOUNTINFO = f"""Data Farming Tool - info about an account

Usage: dftool accountinfo NETWORK TOKEN_ADDR ACCOUNT_ADDR

  NETWORK -- one of {NETWORKS}
  TOKEN_ADDR -- e.g. '0x123..'
  ACCOUNT_ADDR -- account address, e.g. '0x987...'"""
    if len(sys.argv) not in [5]:
        print(HELP_ACCOUNTINFO)
        sys.exit(0)

    # extract inputs
    assert sys.argv[1] == "accountinfo"
    NETWORK = sys.argv[2]
    TOKEN_ADDR = sys.argv[3]
    ACCOUNT_ADDR = sys.argv[4]

    print(f"Arguments: NETWORK={NETWORK}, TOKEN_ADDR={TOKEN_ADDR}"
          f", ACCOUNT_ADDR={ACCOUNT_ADDR}"
    )

    #brownie setup
    brownie.network.connect(NETWORK)

    #release the token
    token = BROWNIE_PROJECT.Simpletoken.at(TOKEN_ADDR)
    balance = token.balanceOf(ACCOUNT_ADDR)
    print(f"For account {ACCOUNT_ADDR[:5]}.., token '{token.symbol()}':")
    print(f"  balance of token : {fromBase18(balance)} {token.symbol()}")

# ========================================================================
def show_chaininfo():
    HELP_CHAININFO = f"""Data Farming Tool - info about a network

Usage: dftool chaininfo NETWORK

  NETWORK -- one of {NETWORKS}"""
    if len(sys.argv) not in [3]:
        print(HELP_CHAININFO)
        sys.exit(0)

    # extract inputs
    assert sys.argv[1] == "chaininfo"
    NETWORK = sys.argv[2]

    print(f"Arguments: NETWORK={NETWORK}")

    #brownie setup
    brownie.network.connect(NETWORK)

    #release the token
    blocks = len(brownie.network.chain)
    print("\nChain info:")
    print(f"  # blocks: {len(brownie.network.chain)}")

# ========================================================================
def _getPrivateAccount():
    private_key = os.getenv('DFTOOL_KEY')
    account = brownie.network.accounts.add(private_key=private_key)
    print(f"For private key DFTOOL_KEY, address is: {account.address}")
    return account

# ========================================================================
# main
def do_main():
    if len(sys.argv) == 1 or sys.argv[1] == "help":
        show_help()

    #write actions
    elif sys.argv[1] == "calc":
        do_calc()
    elif sys.argv[1] == "dispense":
        do_dispense()
    elif sys.argv[1] == "mine":
        do_mine()

    #read actions
    elif sys.argv[1] == "accountinfo":
        show_accountinfo()
    elif sys.argv[1] == "chaininfo":
        show_chaininfo()
    else:
        show_help()

if __name__ == "__main__":
    do_main()
