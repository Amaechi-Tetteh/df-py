#!/usr/bin/env python

import csv
import os
import sys

import brownie

from util.base18 import toBase18, fromBase18

BROWNIE_PROJECT = brownie.project.load("./", name="MyProject")

NETWORKS = ['development', 'eth_mainnet'] #development = ganache

# ========================================================================
HELP_MAIN = """Data Farming Tool - main help

Usage: dftool calc|dispense|..

  dftool calc - calculate rewards
  dftool dispense - airdrop funds based on calculations

  dftool token - create token, for testing
  dftool mine - force chain to pass time (ganache only)

  dftool accountinfo - info about an account
  dftool walletinfo - info about a vesting wallet
  dftool help - this message

Transactions are signed with envvar 'DFTOOL_KEY`.
"""
def show_help():
    print(HELP_MAIN)
    sys.exit(0)
    
# ========================================================================
def do_calc):
    HELP_CALC = f"""Data Farming Tool - calculate rewards

Usage: dftool calc NETWORK OUTPUT_DIR

  NETWORK -- one of {NETWORKS}
  OUTPUT_DIR -- output directory for csv file.
"""

    if len(sys.argv) not in [4]:
        print(HELP_CALC)
        sys.exit(0)

    # extract inputs
    assert sys.argv[1] == "calc"
    NETWORK = sys.argv[2]
    OUTPUT_DIR = sys.argv[3]
    print(f"Arguments: NETWORK={NETWORK}, OUTPUT_DIR={OUTPUT_DIR}")
    
    # handle corner cases
    if os.path.exists(OUTPUT_DIR):
        print(f"\nOutput path '{OUTPUT_DIR}' already exists.  Exiting.\n")
        sys.exit(0)

    # make directory
    os.mkdir(OUTPUT_DIR)
    
    #brownie setup
    brownie.network.connect(NETWORK)
    accounts = brownie.network.accounts
    chain = brownie.network.chain

    #
    print("FIXME: do rest of 'calc' work now!!")

    #
    print(f"OUTPUT_DIR={OUTPUT_DIR}")
    print(f"dftool calc: Done")

# ========================================================================
def do_dispense():
    HELP_DISPENSE = f"""Data Farming Tool - airdrop funds based on calculations

Usage: dftool dispense NETWORK INPUT_DIR

  NETWORK -- one of {NETWORKS}
  INPUT_DIR -- string -- input directory for csv file.
"""
    if len(sys.argv) not in [4]:
        print(HELP_DISPENSE)
        sys.exit(0)

    # extract inputs
    assert sys.argv[1] == "dispense"
    NETWORK = sys.argv[2]
    INPUT_DIR = sys.argv[3]

    print(f"Arguments: NETWORK={NETWORK}, INPUT_DIR={INPUT_DIR}")

    #brownie setup
    brownie.network.connect(NETWORK) 
    accounts = brownie.network.accounts
    from_account = _getPrivateAccount()

    #
    print("FIXME: do rest of 'dispense' work now!!")
    
    print("dftool dispense: Done.")


# ========================================================================
def do_token():
    HELP_TOKEN = f"""Data Farming tool - create test token

Usage: dftool token NETWORK

NETWORK -- one of {NETWORKS}"""
    if len(sys.argv) not in [3]:
        print(HELP_TOKEN)
        sys.exit(0)

    # extract inputs
    assert sys.argv[1] == "token"
    NETWORK = sys.argv[2]

    print(f"Arguments: NETWORK={NETWORK}")

    #brownie setup
    brownie.network.connect(NETWORK) 
    accounts = brownie.network.accounts

    #
    from_account = _getPrivateAccount()

    #deploy wallet
    token = BROWNIE_PROJECT.Simpletoken.deploy(
        "TST", "Test Token", 18, 1e21, {"from": from_account}
    )
    print(f"Token '{token.symbol()}' deployed at address: {token.address}")
    print("dftool token: done")
    
# ========================================================================
def do_mine():
    HELP_MINE = f"""Vesting wallet - force chain to pass time (ganache only)

Usage: dftool mine BLOCKS TIMEDELTA

  BLOCKS -- e.g. 3
  TIMEDELTA -- e.g. 100"""
    if len(sys.argv) not in [4]:
        print(HELP_MINE)
        sys.exit(0)

    # extract inputs
    assert sys.argv[1] == "mine"
    BLOCKS = int(sys.argv[2])
    TIMEDELTA = int(sys.argv[3])

    print(f"Arguments: BLOCKS={BLOCKS}, TIMEDELTA={TIMEDELTA}")

    #brownie setup
    NETWORK = 'development' #hardcoded bc it's the only one we can force
    brownie.network.connect(NETWORK) 
    accounts = brownie.network.accounts
    chain = brownie.network.chain
    from_account = _getPrivateAccount()

    #make time pass
    chain.mine(blocks=BLOCKS, timedelta=TIMEDELTA)
    
    print("dftool mine: Done.")


# ========================================================================
def show_accountinfo():
    HELP_ACCOUNTINFO = f"""Vesting wallet - info about an account

Usage: dftool accountinfo NETWORK TOKEN_ADDR ACCOUNT_ADDR

  NETWORK -- one of {NETWORKS}
  TOKEN_ADDR -- e.g. '0x123..'
  ACCOUNT_ADDR -- account address, e.g. '0x987...'"""
    if len(sys.argv) not in [5]:
        print(HELP_ACCOUNTINFO)
        sys.exit(0)

    # extract inputs
    assert sys.argv[1] == "accountinfo"
    NETWORK = sys.argv[2]
    TOKEN_ADDR = sys.argv[3]
    ACCOUNT_ADDR = sys.argv[4]

    print(f"Arguments: NETWORK={NETWORK}, TOKEN_ADDR={TOKEN_ADDR}"
          f", ACCOUNT_ADDR={ACCOUNT_ADDR}"
    )

    #brownie setup
    brownie.network.connect(NETWORK)

    #release the token
    token = BROWNIE_PROJECT.Simpletoken.at(TOKEN_ADDR)
    balance = token.balanceOf(ACCOUNT_ADDR)
    print(f"For account {ACCOUNT_ADDR[:5]}.., token '{token.symbol()}':")
    print(f"  balance of token : {fromBase18(balance)} {token.symbol()}")

# ========================================================================
def _getPrivateAccount():
    private_key = os.getenv('DFTOOL_KEY')
    account = brownie.network.accounts.add(private_key=private_key)
    print(f"For private key DFTOOL_KEY, address is: {account.address}")
    return account

# ========================================================================
# main
def do_main():
    if len(sys.argv) == 1 or sys.argv[1] == "help":
        show_help()

    #write actions
    elif sys.argv[1] == "calc":
        do_calc()
    elif sys.argv[1] == "dispense":
        do_dispense()
    elif sys.argv[1] == "token":
        do_token()
    elif sys.argv[1] == "mine":
        do_mine()

    #read actions
    elif sys.argv[1] == "accountinfo":
        show_accountinfo()
    else:
        show_help()

if __name__ == "__main__":
    do_main()
