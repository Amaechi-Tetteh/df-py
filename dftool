#!/usr/bin/env python

import csv
import os
import sys

import brownie

from util import blockrange, calcrewards, dispense
from util.constants import BROWNIE_PROJECT as B
from util.base18 import toBase18, fromBase18
from util.graphutil import oceanSubgraphUrl
from util.oceanutil import recordDeployedContracts, OCEANtoken

NETWORKS = ['development', 'eth_mainnet'] #development = ganache

# ========================================================================
HELP = """Usage: dftool calc|dispense|..
Main help.

dftool calc NETWORK START END INTERVAL TOT_OCEAN OUTPUT_DIR - calculate rewards
dftool dispense NETWORK INPUT_DIR AIRDROP_ADDR - airdrop funds

dftool newcontract NETWORK TOKEN_ADDR - deploy new airdrop contract
dftool mine BLOCKS [TIMEDELTA] - force chain to pass time (ganache only)
dftool newacct - generate new account

dftool acctinfo NETWORK ACCOUNT_ADDR [TOKEN_ADDR] - info about an account
dftool chaininfo NETWORK - info about a network
dftool help - this message

Transactions are signed with envvar 'DFTOOL_KEY`.
"""
def show_help():
    print(HELP)
    sys.exit(0)

    
# ========================================================================
def do_calc():
    HELP = f"""Usage: dftool calc NETWORK START END INTERVAL TOT_OCEAN OUTPUT_DIR
Calculate rewards.

NETWORK -- one of {NETWORKS}
START -- block # to start calcs on
END -- block # to end calcs
INTERVAL -- sample every nth block
TOT_OCEAN -- total amount of OCEAN to distribute (in decimal, not wei)
OUTPUT_DIR -- output directory for csv file.

Uses these envvars:
  ADDRESS_FILE -- e.g. for barge ~/.ocean/ocean-contracts/artifacts/address.json
  SUBGRAPH_URI -- e.g. for barge http://127.0.0.1:9000
"""

    if len(sys.argv) not in [2+6]:
        print(HELP)
        sys.exit(0)

    # extract inputs
    assert sys.argv[1] == "calc"
    NETWORK = sys.argv[2]
    START, END, INTERVAL = int(sys.argv[3]), int(sys.argv[4]), int(sys.argv[5])
    TOT_OCEAN = float(sys.argv[6])
    OUTPUT_DIR = sys.argv[7]
    print(f"Arguments:\n NETWORK={NETWORK}" \
          f"\n START={START}\n END={END}\n INTERVAL={INTERVAL}" \
          f"\n TOT_OCEAN={TOT_OCEAN}" \
          f"\n OUTPUT_DIR={OUTPUT_DIR}")
        
    # extract envvars
    ADDRESS_FILE = os.environ.get('ADDRESS_FILE')
    SUBGRAPH_URI = os.environ.get('SUBGRAPH_URI')
    print(f"Envvars:\n ADDRESS_FILE={ADDRESS_FILE}\n " \
          f"SUBGRAPH_URI={SUBGRAPH_URI}")

    # corner cases
    if os.path.exists(OUTPUT_DIR):
        print(f"\nOutput path '{OUTPUT_DIR}' already exists.  Exiting.\n")
        sys.exit(0)
    if ADDRESS_FILE is None:
        print("\nNeed to set envvar ADDRESS_FILE. Exiting.\n"); sys.exit(0)
    if SUBGRAPH_URI is None:
        print("\nNeed to set envvar SUBGRAPH_URI. Exiting.\n"); sys.exit(0)

    # make directory
    os.mkdir(OUTPUT_DIR)
    
    #brownie setup
    brownie.network.connect(NETWORK)
    accounts = brownie.network.accounts
    chain = brownie.network.chain

    #main work
    recordDeployedContracts(ADDRESS_FILE, NETWORK)
    rng = blockrange, BlockRange(START, END, INTERVAL)
    url = oceanSubgraphUrl(SUBGRAPH_URI)
    rewards = calcrewards.queryAndCalcRewards(rng, TOT_OCEAN, url)
    
    #store to csv
    dispense.rewardsToCsv(OUTPUT_DIR)
    
    print(f"dftool calc: Done.")


# ========================================================================
def do_dispense():
    HELP = f"""Usage: dftool dispense NETWORK INPUT_DIR [AIRDROP_ADDR]
Airdrop funds based on calculations.

NETWORK -- one of {NETWORKS}
INPUT_DIR -- input directory for csv file
AIRDROP_ADDR -- airdrop contract. If not given, uses envvar AIRDROP_ADDR
"""
    if len(sys.argv) not in [4, 5]:
        print(HELP)
        sys.exit(0)

    # extract inputs
    assert sys.argv[1] == "dispense"
    NETWORK = sys.argv[2]
    INPUT_DIR = sys.argv[3]
    if len(sys.argv) == 4:
        print("Set AIRDROP_ADDR from envvar")
        AIRDROP_ADDR = os.getenv('AIRDROP_ADDR')
    else:
        AIRDROP_ADDR = sys.argv[4]
        
    print(f"Arguments: NETWORK={NETWORK}, INPUT_DIR={INPUT_DIR}" \
          f", AIRDROP_ADDR={AIRDROP_ADDR}")
    assert AIRDROP_ADDR is not None

    #brownie setup
    brownie.network.connect(NETWORK) 
    accounts = brownie.network.accounts
    from_account = _getPrivateAccount()

    #main work
    dispense.dispenseFromCsv(INPUT_DIR, AIRDROP_ADDR, from_account)

    print("dftool dispense: Done.")

    
# ========================================================================
def do_newcontract():
    HELP = f"""Usage: dftool newcontract NETWORK TOKEN_ADDR
Deploy new airdrop contract.

NETWORK -- one of {NETWORKS}
TOKEN_ADDR -- e.g. address of OCEAN token
"""
    if len(sys.argv) not in [4]:
        print(HELP)
        sys.exit(0)

    # extract inputs
    assert sys.argv[1] == "newcontract"
    NETWORK = sys.argv[2]
    TOKEN_ADDR = sys.argv[3]

    print(f"Arguments: NETWORK={NETWORK}, TOKEN_ADDR={TOKEN_ADDR}")

    #brownie setup
    brownie.network.connect(NETWORK) 
    accounts = brownie.network.accounts

    #main work
    from_account = _getPrivateAccount()
    airdrop = B.Airdrop.deploy(TOKEN_ADDR, {"from": from_account})
    print(f"Deployed new Airdrop contract, with address: {airdrop.address}")
    
    print("dftool newcontract: Done.")


# ========================================================================
# dftool compile
def do_compile():
    os.system("brownie compile")

   
# ========================================================================
def do_mine():
    HELP = f"""Usage: dftool mine BLOCKS [TIMEDELTA]
  Force chain to pass time (ganache only).

  BLOCKS -- e.g. 3
  TIMEDELTA -- e.g. 100"""
    if len(sys.argv) not in [3,4]:
        print(HELP)
        sys.exit(0)

    # extract inputs
    assert sys.argv[1] == "mine"
    BLOCKS = int(sys.argv[2])
    if len(sys.argv) == 4:
        TIMEDELTA = int(sys.argv[3])
    else:
        TIMEDELTA = None

    print(f"Arguments: BLOCKS={BLOCKS}, TIMEDELTA={TIMEDELTA}")

    #brownie setup
    NETWORK = 'development' #hardcoded bc it's the only one we can force
    brownie.network.connect(NETWORK) 
    accounts = brownie.network.accounts
    chain = brownie.network.chain
    from_account = _getPrivateAccount()

    #make time pass
    if TIMEDELTA is None:
        chain.mine(blocks=BLOCKS, timedelta=TIMEDELTA)
    else:
        chain.mine(blocks=BLOCKS)
        
    print("dftool mine: Done.")


# ========================================================================
def do_newacct():
    HELP = f"""Usage: dftool newacct
Generate new account.
"""
    if len(sys.argv) not in [2]:
        print(HELP)
        sys.exit(0)

    # extract inputs
    assert sys.argv[1] == "newacct"

    #brownie setup
    NETWORK = 'development' #hardcoded bc it's the only one we can force
    brownie.network.connect(NETWORK) 
    account = brownie.network.accounts.add()
    
    print("Generated new account:")
    print(f" private_key = {account.private_key}")
    print(f" address = {account.address}")
    print(f" For other dftools: export DFTOOL_KEY={account.private_key}")

# ========================================================================
def show_acctinfo():
    HELP = f"""Usage: dftool acctinfo NETWORK ACCOUNT_ADDR [TOKEN_ADDR]
Info about an account.

NETWORK -- one of {NETWORKS}
ACCOUNT_ADDR -- e.g. '0x987...' or '4'. If the latter, uses accounts[i]
TOKEN_ADDR -- e.g. '0x123..'

If envvar ADDRESS_FILE is not None, it gives balance for OCEAN token too.
"""
    if len(sys.argv) not in [4,5]:
        print(HELP)
        sys.exit(0)

    # extract inputs
    assert sys.argv[1] == "acctinfo"
    NETWORK = sys.argv[2]
    ACCOUNT_ADDR = sys.argv[3]
    TOKEN_ADDR = sys.argv[4] if len(sys.argv) >= 5 else None

    brownie.network.connect(NETWORK)
    if len(str(ACCOUNT_ADDR)) == 1:
        addr_i = int(ACCOUNT_ADDR)
        ACCOUNT_ADDR = brownie.accounts[addr_i]
    
    #do work
    print("Account info:")
    print(f"  Address = {ACCOUNT_ADDR}")

    if TOKEN_ADDR is not None:
        token = B.Simpletoken.at(TOKEN_ADDR)
        balance = token.balanceOf(ACCOUNT_ADDR)
        print(f"  {fromBase18(balance)} {token.symbol()}")

    #Give balance for OCEAN token too.
    ADDRESS_FILE = os.environ.get('ADDRESS_FILE')
    if ADDRESS_FILE is not None:
        recordDeployedContracts(ADDRESS_FILE, NETWORK)
        OCEAN = OCEANtoken()
        if OCEAN.address != TOKEN_ADDR:
            print(f"  {fromBase18(OCEAN.balanceOf(ACCOUNT_ADDR))} OCEAN")
            
        

# ========================================================================
def show_chaininfo():
    HELP = f"""Usage: dftool chaininfo NETWORK
Info about a network.

NETWORK -- one of {NETWORKS}"""
    if len(sys.argv) not in [3]:
        print(HELP)
        sys.exit(0)

    # extract inputs
    assert sys.argv[1] == "chaininfo"
    NETWORK = sys.argv[2]

    #do work
    brownie.network.connect(NETWORK)
    blocks = len(brownie.network.chain)
    print("\nChain info:")
    print(f"  # blocks: {len(brownie.network.chain)}")

# ========================================================================
def _getPrivateAccount():
    private_key = os.getenv('DFTOOL_KEY')
    assert private_key is not None, "Need to set envvar DFTOOL_KEY"
    account = brownie.network.accounts.add(private_key=private_key)
    print(f"For private key DFTOOL_KEY, address is: {account.address}")
    return account

# ========================================================================
# main
def do_main():
    if len(sys.argv) == 1 or sys.argv[1] == "help":
        show_help()

    #write actions
    elif sys.argv[1] == "calc":
        do_calc()
    elif sys.argv[1] == "compile":
        do_compile()
    elif sys.argv[1] == "newcontract":
        do_newcontract()
    elif sys.argv[1] == "dispense":
        do_dispense()
    elif sys.argv[1] == "mine":
        do_mine()
    elif sys.argv[1] == "newacct":
        do_newacct()

    #read actions
    elif sys.argv[1] == "acctinfo":
        show_acctinfo()
    elif sys.argv[1] == "chaininfo":
        show_chaininfo()
    else:
        show_help()

if __name__ == "__main__":
    do_main()
